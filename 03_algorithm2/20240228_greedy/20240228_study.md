# 20240228 부분집합, 조합, 그리디 필기

## 부분 집합

### 집합에서 부분 집합을 찾아내는 구현 방법
- 완전탐색
  - 재귀호출을 이용한 완전탐색으로, 부분집합을 구할 수 있다.
  - 규모가 커지면 좋지않음
- Binary Counting
  - 2진수 & 비트연산을 이용하여, 부분집합을 구할 수 있다

### 바이너리 카운팅
- 원소 수에 해당하는 N개의 비트열을 이용한다
- 예시
  - {A, B, C} 라는 집합의 경우
  - 0 0 1 이면 {A}를 나타냄
  - 1 1 0 이면 {B, C}를 나타냄

#### 집합의 총 개수
- 만들 수 있는 집합의 총 개수는 2^n개이다.
- 2^n은 1 << n 공식을 이용하여 빠르게 구할 수 있음
```python
print(pow(2, 3))
print(1<<3)
```

#### 이진수가 주어지면 집합의 부분집합을 출력하는 함수
- ex) 0b110이 주어지면 BC를 출력하는 함수
```python
arr = ['A', 'B', 'C']
n = len(arr)

def get_sub(tar):
  for i in range(n):

    # 맨 뒤의 비트가 1인지 확인
    if tar & 0x1:
      print(arr[i], end='')
    # 검사한 자리를 제거
    tar >>= 1

get_sub(6) # 함수 인자가 6 -> {B,C}
for tar in range(1<<n): # 부분집합을 모두 출력
  print('{', end='')
  get_sub(tar)
  print('}')
```

## 조합
- 서로 다른 n개의 원소 중 r개를 순서 없이 골라낸 것을 조합이라고 부른다

- 순열과 조합 차이
  - 순열 : {A,B,C,D,E} 5명 중 1등, 2등, 3등 뽑기 -> 순서가 존재
  - 조합 : 5명중 3명 뽑기 -> 순서가 없음

### 구현
- 5개 중 3개를 뽑는다면 -> 3중 for로 구현
- 재귀 호출로 구현해야함
```python
arr = ['A', 'B', 'C', 'D', 'E']
path = []
n = 3

def run(lev, start):
  if lev == n:
    print(path)
    return

  for i in range(start, 5):
    path.append(arr[i])
    run(lev + 1, i + 1)
    path.pop()

run(0, 0)
```

## 탐욕 알고리즘

### 개념
- 결정이 필요할 때, 현재 기준으로 가장 좋아보이는 선택지로 결정하여 답을 도축하는 알고리즘

