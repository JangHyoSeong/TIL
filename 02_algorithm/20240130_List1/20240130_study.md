# 20240130 필기

## 카운팅 정렬 (Counting Sort)
항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여 선형 시간에 정렬하는 효율적인 알고리즘
- 제한 사항
  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
  - 각 하옥의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다
  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다
  
- 시간 복잡도 : O(n) + k, n은 리스트의 길이. k는 정수의 최대값

#### 코드
```python
arr = [0, 4, 1, 3, 1, 2 ,4 ,1]

# 1단계
# Data에서 각 항목들의 발생 회수를 세고, 
# 정수 항목들로 직접 인덱스 되는 카운트 배열counts에 저장한다.

# counts 배열 : 숫자를 세는 배열
# temp 배열 : 정렬된 숫자가 들어갈 배열
counts = [0] * (max(arr) + 1)
temp = [0] * len(arr)

# counts 배열로 어느 원소가 얼마나 나왔는지 셈
for i in arr:
    counts[i] += 1

# counts의 개수를 누적하여 원소를 조정
for i in range(1, len(counts)):
    counts[i] += counts[i-1]

# 카운트 배열을 통해 temp에 정렬된 숫자를 삽입
for i in range(len(arr)-1, -1, -1):
    counts[arr[i]] -= 1
    temp[counts[arr[i]]] = arr[i]

print(temp)
```
- 비교환 방식의 알고리즘이며, n이 비교적 작은 경우만 가능하다.

## Baby-gin Game
- 6개의 숫자를 입력받을 때, 숫자 3개가 연속되면 run, 숫자 3개가 같으면 triplet이다.
- 6개의 숫자가 모두 run과 triplet으로 이루어진다면 baby-gin이다.
- 어떻게 판별할 것인가?

### 완전 검색
- 완전 검색 방법은 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법이다
- Brute-force 혹은 generate-and-test 기법이라고도 불린다
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다
- 일반적으로 경우의 수가 상대적으로 작을 때 유용하다
<br><br>

- 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.
- 자격검정평가 등에서 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 좋다.

### Baby-gin 접근
- 고려할 수 있는 모든 경우의 수 생성하기
  - 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복 포함)
  - 예를들어 [2, 3, 5, 7, 7, 7]을 받은 경우, 순열을 생성하여 순서를 바꿀 수 있음
  - 앞의 3자리와 뒤의 3자리를 잘라, run과 triplet 여부를 테스트하고, baby-gin 여부를 판단

### 순열 생성

#### **순열**
- 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열하는 것
- 서로 다른 n개중 r개를 택하는 순열은 nPr로 표현한다
- nPr = n * (n-1) * (n-2) * ... * (n-r+1)
- nPn = n!

### 그리디 알고리즘 (탐욕 알고리즘)
- 탐욕 알고리즘은 최적해를 구하는데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다
- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여 그것이 최적이라는 보장은 없다
- 일반적으로 머릿속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy접근이 된다

#### **동작 과정**
1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분해 집합에 추가한다.
2. 실행 가능성 검사 : 새로운 부분해 집합이 실행 가능한지 확인한다. 곧, 문제의 제약 조건을 위반하지 않는지를 검사한다.
3. 해 검사 : 새로운 부분해 집합이 문제의 해가 되는지를 확인한다. 아직 전체 문제의 해가 완성되지 않았다면 1의 해 선택부터 다시 시작한다.

#### **그리디 알고리즘의 예**
- 거스름돈 줄이기
  - 어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일까?
  - 1. 해 선택 : 가장 좋은 해를 선택한다. 단위가 큰 동전으로만 거스름돈을 만드려면 동전의 개수가 줄어드므로, 고를 수 있는 가장 단위가 큰 동전을 하나 거스름돈에 추가한다.
  - 2. 실행 가능성 검사 : 거스름돈이 손님에게 내드려야 할 액수를 초과하는지 확인한다. 초과한다면 마지막에 추가한 동전을 거스름돈에서 빼고, 1로 돌아가서 현재보다 한 단계 작은 단위의 동전을 추가한다
  - 3. 해 검사 : 거스름돈 문제의 해는 당연히 거스름돈이 손님에게 내드려야 하는 액수와 일치해야 한다. 거스름돈을 확인해서 액수와 맞지 않다면 다시 1로 돌아간다.
